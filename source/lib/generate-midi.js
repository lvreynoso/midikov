// generate-midi.js

import midiFile from 'midifile'
import midiEvents from 'midievents'
import fs from 'fs'

import Queue from './queue.js'

const START_TOKEN = 'START_TOKEN'
const STOP_TOKEN = 'STOP_TOKEN'

// markov data will be an object with "map" and "meta" properties.
// the values of these properties will be a markov map of notes
// and a histogram for metadata, respectively.
// the markov data is generated by generate-map.js

const generate = (markovData, order, category) => {

    // first, let's build the metadata.
    let metaData = {
        ticksPerBeat: undefined,
        SMPTEFrames: undefined,
        ticksPerFrame: undefined,
        keySignature: undefined,
        timeSignature: undefined,
        tempo: undefined
    }

    // first, the simple properties.
    // prefer ticks per beat.
    if (Object.getOwnPropertyNames(markovData.meta['ticksPerBeat']).length > 0) {
        metaData.ticksPerBeat = weightedChoice(markovData.meta['ticksPerBeat']);
    }
    if (Object.getOwnPropertyNames(markovData.meta['SMPTEFrames']).length > 0) {
        metaData.SMPTEFrames = weightedChoice(markovData.meta['SMPTEFrames']);
    }
    if (Object.getOwnPropertyNames(markovData.meta['ticksPerFrame']).length > 0) {
        metaData.ticksPerFrame = weightedChoice(markovData.meta['ticksPerFrame']);
    }

    // now to build events for the key and time signatures, and the tempo.
    // key signature
    let codedKeySignature = '';
    if (Object.getOwnPropertyNames(markovData.meta['keySignature']).length > 0) {
        codedKeySignature = weightedChoice(markovData.meta['keySignature']);
    }
    // console.log(codedKeySignature);
    let keyScaleArray = codedKeySignature.split('-');
    let keySignature = {
        delta: 0x00,
        type: 0xff,
        subtype: 0x59,
        length: 0x02,
        key: parseInt(keyScaleArray[0], 10),
        scale: parseInt(keyScaleArray[1], 10)
    }
    // console.log(keyScaleArray);
    metaData.keySignature = keySignature;

    // time signature
    let codedTimeSignature = '';
    if (Object.getOwnPropertyNames(markovData.meta['timeSignature']).length > 0) {
        codedTimeSignature = weightedChoice(markovData.meta['timeSignature']);
    }
    // console.log(codedTimeSignature);
    let timeDataStringArray = codedTimeSignature.split('-');
    let timeDataArray = timeDataStringArray.map(element => {
        return parseInt(element, 10);
    });

    let timeSignature = {
        delta: 0x00,
        type: 0xff,
        subtype: 0x58,
        length: 0x04,
        data: timeDataArray,
        param1: timeDataArray[0],
        param2: timeDataArray[1],
        param3: timeDataArray[2],
        param4: timeDataArray[3]
    }
    metaData.timeSignature = timeSignature;

    // tempo event
    let codedTempo = '';
    if (Object.getOwnPropertyNames(markovData.meta['tempo']).length > 0) {
        codedTempo = weightedChoice(markovData.meta['tempo']);
    }
    // console.log(codedTempo);
    let tempo = {
        delta: 0x00,
        type: 0xff,
        subtype: 0x51,
        length: 0x03,
        tempo: parseInt(codedTempo, 10),
    }
    // tempo.tempo = parseInt(codedTempo, 10);
    metaData.tempo = tempo;

    // console.log(metaData);
    // that finishes the metadata


    let tracks = {};
    // now we generate each track
    for (let i = 1; i < 4; i++) {
        tracks[i] = generateTrack(markovData.map, order, 450)
    }

    let generatedSong = {
        trackNotes: tracks,
        metaData: metaData
    }

    return generatedSong;
}

function generateTrack(noteMap, markovOrder, distance) {
    let trackNotes = [];

    let stateQueue = new Queue(markovOrder);

    // get our first Markov state. find all the keys that start with
    // a start token, then randomly select from them.
    let markovKeys = Object.keys(noteMap);
    let startingPossibilities = [];
    markovKeys.forEach(markovKey => {
        // console.log(markovKey);
        let decodedKey = markovKey.split('|');
        if (decodedKey[0] == START_TOKEN) {
            startingPossibilities.push(markovKey);
        }
    });
    // console.log(`Starting possibilities: ${startingPossibilities}`);
    let state = startingPossibilities[Math.floor(Math.random() * startingPossibilities.length)];
    state = state.split('|')
    console.log(`First state:`);
    console.log(state);
    state.forEach(token => {
        stateQueue.enqueue(token);
    });

    // now walk the path
    for (let step = 0; step <= distance; step++) {
        // save the queue state
        state = stateQueue.items();
        // step through the queue
        let currentNote = stateQueue.dequeue();
        // find another word to start the queue
        if (currentNote == STOP_TOKEN) {
            let allKeys = Object.keys(noteMap);
            let newStartingPossibilities = [];
            allKeys.forEach(allKey => {
                let decodedKey = allKey.split('|')
                if (decodedKey[0] == START_TOKEN) {
                    newStartingPossibilities.push(allKey);
                }
            });
            state = newStartingPossibilities[Math.floor(Math.random() * newStartingPossibilities.length)];
            state = state.split('|')
            state.forEach(token => {
                stateQueue.enqueue(token);
            });
            currentNote = stateQueue.dequeue;
        }
        // start tokens aren't written
        if (currentNote == START_TOKEN) {
            let stateToken = state.join('|')
            let setOfPossibilities = noteMap[stateToken];
            let nextNote = weightedChoice(setOfPossibilities);
            stateQueue.enqueue(nextNote);
            state = stateQueue.items();
            currentNote = stateQueue.dequeue();
        }
        // enqueue our next token
        let stateToken = state.join('|')
        let setOfPossibilities = noteMap[stateToken];
        let nextNote = weightedChoice(setOfPossibilities);
        stateQueue.enqueue(nextNote);

        // turn the current note into an event
        let decodedNote = nextNote.split('-');
        let note = {
            pitch: parseInt(decodedNote[0], 10),
            velocity: parseInt(decodedNote[1], 10),
            alpha: parseInt(decodedNote[2], 10),
            duration: parseInt(decodedNote[3], 10),
            instrument: parseInt(decodedNote[4], 10)
        }
        trackNotes.push(note);

        // debugging
        if (trackNotes.length == 1) {
            // console.log(trackNotes);
        }
    }
    return trackNotes;
}

// need a random weighted choice function
function weightedChoice(histogram) {
    // let histogram = hashMap[property];
    let choice = '';
    let weightSum = Object.values(histogram).reduce((sum, element) => {
        return sum + element;
    })
    // console.log(weightSum);
    let randomWeight = Math.floor(Math.random() * weightSum)
    // console.log(randomWeight);

    let keys = Object.keys(histogram)
    // console.log(keys);
    let chosen = false
    keys.forEach(key => {
        if ((randomWeight - histogram[key] <= 0) && (chosen == false)) {
            choice = key;
            chosen = true;
        } else if (chosen == false) {
            randomWeight -= histogram[key];
        }
    });

    return choice;
}

export default generate;
