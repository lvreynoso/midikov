{"version":3,"sources":["../../source/lib/generate-map.js"],"names":["START_TOKEN","STOP_TOKEN","generateMap","midiArray","order","category","tokenArray","forEach","song","trackNumbers","Object","keys","trackNotes","sort","a","b","parseInt","track","notes","push","note","noteToken","tokenize","markovMap","startingItems","console","log","n","stateTracker","Queue","item","enqueue","items","state","stringify","index","length","newToken","newState","undefined","markovMetaData","ticksPerBeat","SMPTEFrames","ticksPerFrame","keySignature","timeSignature","tempo","meta","metaData","properties","property","rawData","dataPoint","key","scale","param1","param2","param3","param4","markovData","map","token","pitch","velocity","alpha","duration","tokens","outputString","element","i"],"mappings":"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","sourcesContent":["// generate-map.js\n// take an array of midi info and turn it into\n// a markov map usable for generating songs\n\nimport midiFile from 'midifile'\nimport midiEvents from 'midievents'\nimport fs from 'fs'\n// import _ from 'lodash'\n\nimport Queue from './queue.js'\n\nconst START_TOKEN = 'START_TOKEN'\nconst STOP_TOKEN = 'STOP_TOKEN'\n\n// midiArray will be an array of midiData objects, as described in\n// transform-midi.js. order and category will be passed by the controller\n\nconst generateMap = (midiArray, order, category) => {\n    // generate a map of notes.\n    // and the first part of that - shove all the notes together.\n    // we convert them to strings for easier comparison and storage.\n    let tokenArray = [];\n    midiArray.forEach(song => {\n        // get a list of tracks\n        let trackNumbers = Object.keys(song.trackNotes);\n        trackNumbers.sort((a, b) => {\n            return parseInt(a) - parseInt(b);\n        });\n        // go through each track and push notes to the tokenArray\n        trackNumbers.forEach(track => {\n            let notes = song.trackNotes[track];\n            tokenArray.push(START_TOKEN);\n            notes.forEach(note => {\n                let noteToken = tokenize(note);\n                tokenArray.push(noteToken);\n            })\n            tokenArray.push(STOP_TOKEN);\n        })\n    })\n    // now we should have an array of note tokens.\n    // console.log(tokenArray);\n    // indeed we do.\n\n    // second - we go through the tokens and build up a markov map.\n    // it's better in the original python.\n    let markovMap = {};\n    let startingItems = [];\n    console.log(`Order: ${order}`);\n    for (let n = 0; n < order; n++) {\n        startingItems.push(tokenArray[n]);\n    }\n    console.log(`Starting items: ${startingItems}`);\n    let stateTracker = new Queue(order);\n    startingItems.forEach(item => {\n        stateTracker.enqueue(item);\n    });\n    // let trackerItems = stateTracker.items();\n\n    // since javascript does not have tuples and arrays cannot be used\n    // as keys in an object, we need to transform the state into a string\n    // where tokens are separated by a pipe '|'\n    console.log(stateTracker.items());\n    let state = stringify(stateTracker.items());\n\n\n    // console.log(state);\n    markovMap[state] = {};\n\n    // this is a very big loop.\n    for (let index = order; index < tokenArray.length; index++) {\n        let newToken = tokenArray[index];\n        stateTracker.enqueue(newToken);\n        let newState = stringify(stateTracker.items());\n\n        // add the new state to the markov map\n        if (markovMap[newState] == undefined) {\n            markovMap[newState] = {}\n        }\n\n        // update the token count for the current state\n        if (markovMap[state][newToken] == undefined) {\n            markovMap[state][newToken] = 1;\n        } else {\n            markovMap[state][newToken] += 1;\n        }\n        state = newState;\n    }\n    // console.log(markovMap);\n\n    // write map to disk\n    // let stringMap = JSON.stringify(markovMap);\n    // let filename = `${category}_${order}.markov`\n    // let path = `temp/${filename}`;\n    // let writeStream = fs.createWriteStream(path);\n    // writeStream.write(stringMap, 'utf8');\n    // writeStream.on('finish', () => {\n    //     console.log('Wrote data to file.');\n    // })\n    // writeStream.close();\n\n    // did it work?\n    // yes it did. wow.\n\n    // ok now we have to collect the meta information\n    // i'm just going to do a very simple statistical sampling\n\n    // our data structure\n    let markovMetaData = {\n        ticksPerBeat: {},\n        SMPTEFrames: {},\n        ticksPerFrame: {},\n        keySignature: {},\n        timeSignature: {},\n        tempo: {}\n    }\n\n    // copy the meta properties\n    midiArray.forEach(song => {\n        let meta = song.metaData;\n        let properties = Object.keys(meta);\n        properties.forEach(property => {\n            if (meta[property] != undefined) {\n                let rawData = meta[property];\n                let dataPoint = ''\n                // what we copy depends on the property\n                switch (property) {\n                    case 'ticksPerBeat':\n                    case 'SMPTEFrames':\n                    case 'ticksPerFrame':\n                        dataPoint = rawData;\n                        break;\n                    case 'keySignature':\n                        dataPoint = `${rawData.key}-${rawData.scale}`;\n                        break;\n                    case 'timeSignature':\n                        dataPoint = `${rawData.param1}-${rawData.param2}-${rawData.param3}-${rawData.param4}`;\n                        break;\n                    case 'tempo':\n                        dataPoint = `${rawData.tempo}`;\n                        break;\n                    default:\n                        break;\n                }\n                if (markovMetaData[property][dataPoint] == undefined) {\n                    markovMetaData[property][dataPoint] = 1;\n                } else {\n                    markovMetaData[property][dataPoint] += 1;\n                }\n            }\n        });\n    });\n\n    // write metadata to disk\n    // let metaStringMap = JSON.stringify(markovMetaData);\n    // let metaFilename = `${category}_${order}.meta`\n    // let metaPath = `temp/${metaFilename}`;\n    // let metaWriteStream = fs.createWriteStream(metaPath);\n    // metaWriteStream.write(metaStringMap, 'utf8');\n    // metaWriteStream.on('finish', () => {\n    //     console.log('Wrote data to file.');\n    // })\n    // metaWriteStream.close();\n\n    // did it work?\n    // yes!\n\n    let markovData = {\n        map: markovMap,\n        meta: markovMetaData\n    };\n\n    return markovData;\n}\n\nfunction tokenize(note) {\n    let token = `${note.pitch}-${note.velocity}-${note.alpha}-${note.duration}`\n    return token;\n}\n\nfunction stringify(tokens) {\n    let outputString = '';\n    tokens.forEach((element, i) => {\n        if (i == 0) {\n            outputString += `${element}`;\n        } else {\n            outputString += `|${element}`;\n        }\n    });\n    return outputString;\n}\n\nexport default generateMap;\n"],"file":"generate-map.js"}