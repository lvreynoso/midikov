{"version":3,"sources":["../../source/lib/generate-midi.js"],"names":["START_TOKEN","STOP_TOKEN","generate","markovData","order","category","metaData","ticksPerBeat","undefined","SMPTEFrames","ticksPerFrame","keySignature","timeSignature","tempo","Object","getOwnPropertyNames","meta","length","weightedChoice","codedKeySignature","keyScaleArray","split","delta","type","subtype","key","parseInt","scale","codedTimeSignature","timeDataStringArray","timeDataArray","map","element","data","param1","param2","param3","param4","codedTempo","tracks","i","generateTrack","generatedSong","trackNotes","noteMap","markovOrder","distance","stateQueue","Queue","markovKeys","keys","startingPossibilities","forEach","markovKey","decodedKey","push","state","Math","floor","random","console","log","token","enqueue","step","items","currentNote","dequeue","allKeys","newStartingPossibilities","allKey","stateToken","join","setOfPossibilities","nextNote","decodedNote","note","pitch","velocity","alpha","duration","histogram","choice","weightSum","values","reduce","sum","randomWeight","chosen"],"mappings":"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","sourcesContent":["// generate-midi.js\n\nimport midiFile from 'midifile'\nimport midiEvents from 'midievents'\nimport fs from 'fs'\n\nimport Queue from './queue.js'\n\nconst START_TOKEN = 'START_TOKEN'\nconst STOP_TOKEN = 'STOP_TOKEN'\n\n// markov data will be an object with \"map\" and \"meta\" properties.\n// the values of these properties will be a markov map of notes\n// and a histogram for metadata, respectively.\n// the markov data is generated by generate-map.js\n\nconst generate = (markovData, order, category) => {\n\n    // first, let's build the metadata.\n    let metaData = {\n        ticksPerBeat: undefined,\n        SMPTEFrames: undefined,\n        ticksPerFrame: undefined,\n        keySignature: undefined,\n        timeSignature: undefined,\n        tempo: undefined\n    }\n\n    // first, the simple properties.\n    // prefer ticks per beat.\n    if (Object.getOwnPropertyNames(markovData.meta['ticksPerBeat']).length > 0) {\n        metaData.ticksPerBeat = weightedChoice(markovData.meta['ticksPerBeat']);\n    }\n    if (Object.getOwnPropertyNames(markovData.meta['SMPTEFrames']).length > 0) {\n        metaData.ticksPerBeat = weightedChoice(markovData.meta['SMPTEFrames']);\n    }\n    if (Object.getOwnPropertyNames(markovData.meta['ticksPerFrame']).length > 0) {\n        metaData.ticksPerBeat = weightedChoice(markovData.meta['ticksPerFrame']);\n    }\n\n    // now to build events for the key and time signatures, and the tempo.\n    // key signature\n    let codedKeySignature = '';\n    if (Object.getOwnPropertyNames(markovData.meta['keySignature']).length > 0) {\n        codedKeySignature = weightedChoice(markovData.meta['keySignature']);\n    }\n    // console.log(codedKeySignature);\n    let keyScaleArray = codedKeySignature.split('-');\n    let keySignature = {\n        delta: 0x00,\n        type: 0xff,\n        subtype: 0x59,\n        length: 0x02,\n        key: parseInt(keyScaleArray[0], 10),\n        scale: parseInt(keyScaleArray[1], 10)\n    }\n    // console.log(keyScaleArray);\n    // keySignature.key = parseInt(keyScaleArray[0], 10);\n    // keySignature.scale = parseInt(keyScaleArray[1], 10);\n    metaData.keySignature = keySignature;\n\n    // time signature\n    let codedTimeSignature = '';\n    if (Object.getOwnPropertyNames(markovData.meta['timeSignature']).length > 0) {\n        codedTimeSignature = weightedChoice(markovData.meta['timeSignature']);\n    }\n    // console.log(codedTimeSignature);\n    let timeDataStringArray = codedTimeSignature.split('-');\n    let timeDataArray = timeDataStringArray.map(element => {\n        return parseInt(element, 10);\n    });\n\n    let timeSignature = {\n        delta: 0x00,\n        type: 0xff,\n        subtype: 0x58,\n        length: 0x04,\n        data: timeDataArray,\n        param1: timeDataArray[0],\n        param2: timeDataArray[1],\n        param3: timeDataArray[2],\n        param4: timeDataArray[3]\n    }\n    // timeSignature.data = timeDataArray;\n    // timeSignature.param1 = timeDataArray[0];\n    // timeSignature.param2 = timeDataArray[1];\n    // timeSignature.param3 = timeDataArray[2];\n    // timeSignature.param4 = timeDataArray[3];\n    metaData.timeSignature = timeSignature;\n\n    // tempo event\n    let codedTempo = '';\n    if (Object.getOwnPropertyNames(markovData.meta['tempo']).length > 0) {\n        codedTempo = weightedChoice(markovData.meta['tempo']);\n    }\n    // console.log(codedTempo);\n    let tempo = {\n        delta: 0x00,\n        type: 0xff,\n        subtype: 0x51,\n        length: 0x03,\n        tempo: parseInt(codedTempo, 10),\n    }\n    // tempo.tempo = parseInt(codedTempo, 10);\n    metaData.tempo = tempo;\n\n    // console.log(metaData);\n    // that finishes the metadata\n\n\n    let tracks = {};\n    // now we generate each track\n    // let firstTrack = generateTrack(markovData.map, order, 450)\n    // tracks[1] = firstTrack;\n    // console.log('1 track written');\n    // console.log(tracks);\n    for (let i = 1; i < 4; i++) {\n        tracks[i] = generateTrack(markovData.map, order, 450)\n    }\n\n    let generatedSong = {\n        trackNotes: tracks,\n        metaData: metaData\n    }\n\n    return generatedSong;\n}\n\nfunction generateTrack(noteMap, markovOrder, distance) {\n    let trackNotes = [];\n\n    let stateQueue = new Queue(markovOrder);\n\n    // get our first Markov state. find all the keys that start with\n    // a start token, then randomly select from them.\n    let markovKeys = Object.keys(noteMap);\n    let startingPossibilities = [];\n    markovKeys.forEach(markovKey => {\n        // console.log(markovKey);\n        let decodedKey = markovKey.split('|');\n        if (decodedKey[0] == START_TOKEN) {\n            startingPossibilities.push(markovKey);\n        }\n    });\n    // console.log(`Starting possibilities: ${startingPossibilities}`);\n    let state = startingPossibilities[Math.floor(Math.random() * startingPossibilities.length)];\n    state = state.split('|')\n    console.log(`First state:`);\n    console.log(state);\n    state.forEach(token => {\n        stateQueue.enqueue(token);\n    });\n\n    // now walk the path\n    for (let step = 0; step <= distance; step++) {\n        // save the queue state\n        state = stateQueue.items();\n        // step through the queue\n        let currentNote = stateQueue.dequeue();\n        // find another word to start the queue\n        if (currentNote == STOP_TOKEN) {\n            let allKeys = Object.keys(noteMap);\n            let newStartingPossibilities = [];\n            allKeys.forEach(allKey => {\n                let decodedKey = allKey.split('|')\n                if (decodedKey[0] == START_TOKEN) {\n                    newStartingPossibilities.push(allKey);\n                }\n            });\n            state = newStartingPossibilities[Math.floor(Math.random() * newStartingPossibilities.length)];\n            state = state.split('|')\n            state.forEach(token => {\n                stateQueue.enqueue(token);\n            });\n            currentNote = stateQueue.dequeue;\n        }\n        // start tokens aren't written\n        if (currentNote == START_TOKEN) {\n            let stateToken = state.join('|')\n            let setOfPossibilities = noteMap[stateToken];\n            let nextNote = weightedChoice(setOfPossibilities);\n            stateQueue.enqueue(nextNote);\n            state = stateQueue.items();\n            currentNote = stateQueue.dequeue();\n        }\n        // enqueue our next token\n        let stateToken = state.join('|')\n        let setOfPossibilities = noteMap[stateToken];\n        let nextNote = weightedChoice(setOfPossibilities);\n        stateQueue.enqueue(nextNote);\n\n        // turn the current note into an event\n        let decodedNote = nextNote.split('-');\n        let note = {\n            pitch: parseInt(decodedNote[0], 10),\n            velocity: parseInt(decodedNote[1], 10),\n            alpha: parseInt(decodedNote[2], 10),\n            duration: parseInt(decodedNote[3], 10)\n        }\n        // note.pitch = parseInt(decodedNote[0], 10)\n        // note.velocity = parseInt(decodedNote[1], 10)\n        // note.alpha = parseInt(decodedNote[2], 10)\n        // note.duration = parseInt(decodedNote[3], 10)\n        trackNotes.push(note);\n\n        // debugging\n        if (trackNotes.length == 1) {\n            // console.log(trackNotes);\n        }\n    }\n    return trackNotes;\n}\n\n// need a random weighted choice function\nfunction weightedChoice(histogram) {\n    // let histogram = hashMap[property];\n    let choice = '';\n    let weightSum = Object.values(histogram).reduce((sum, element) => {\n        return sum + element;\n    })\n    // console.log(weightSum);\n    let randomWeight = Math.floor(Math.random() * weightSum)\n    // console.log(randomWeight);\n\n    let keys = Object.keys(histogram)\n    // console.log(keys);\n    let chosen = false\n    keys.forEach(key => {\n        if ((randomWeight - histogram[key] <= 0) && (chosen == false)) {\n            choice = key;\n            chosen = true;\n        } else if (chosen == false) {\n            randomWeight -= histogram[key];\n        }\n    });\n\n    return choice;\n}\n\nexport default generate;\n"],"file":"generate-midi.js"}