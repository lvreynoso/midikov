{"version":3,"sources":["../../source/lib/generate-midi.js"],"names":["START_TOKEN","STOP_TOKEN","generate","markovData","order","category","metaData","ticksPerBeat","undefined","SMPTEFrames","ticksPerFrame","keySignature","timeSignature","tempo","Object","getOwnPropertyNames","meta","length","weightedChoice","codedKeySignature","delta","type","subtype","key","scale","keyScaleArray","split","parseInt","codedTimeSignature","data","param1","param2","param3","param4","timeDataStringArray","timeDataArray","map","element","codedTempo","tracks","i","generateTrack","generatedSong","trackNotes","noteMap","markovOrder","distance","stateQueue","Queue","markovKeys","keys","startingPossibilities","forEach","markovKey","decodedKey","push","state","Math","floor","random","console","log","token","enqueue","step","items","currentNote","dequeue","allKeys","newStartingPossibilities","allKey","stateToken","join","setOfPossibilities","nextNote","decodedNote","note","pitch","velocity","alpha","duration","histogram","choice","weightSum","values","reduce","sum","randomWeight","chosen"],"mappings":"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","sourcesContent":["// generate-midi.js\n\nimport midiFile from 'midifile'\nimport midiEvents from 'midievents'\nimport fs from 'fs'\n\nimport Queue from './queue.js'\n\nconst START_TOKEN = 'START_TOKEN'\nconst STOP_TOKEN = 'STOP_TOKEN'\n\n// markov data will be an object with \"map\" and \"meta\" properties.\n// the values of these properties will be a markov map of notes\n// and a histogram for metadata, respectively.\n// the markov data is generated by generate-map.js\n\nconst generate = (markovData, order, category) => {\n    // let sampleObject = {\n    //     \"ticksPerBeat\": {\n    //         \"96\":2,\n    //         \"120\":38,\n    //         \"192\":8,\n    //         \"240\":3,\n    //         \"384\":6,\n    //         \"480\":2,\n    //         \"960\":2,\n    //         \"1024\":2\n    //     }\n    // }\n    // let beat = weightedChoice(sampleObject, 'ticksPerBeat');\n\n    // first, let's build the metadata.\n    let metaData = {\n        ticksPerBeat: undefined,\n        SMPTEFrames: undefined,\n        ticksPerFrame: undefined,\n        keySignature: undefined,\n        timeSignature: undefined,\n        tempo: undefined\n    }\n\n    // first, the simple properties.\n    // prefer ticks per beat.\n    if (Object.getOwnPropertyNames(markovData.meta['ticksPerBeat']).length > 0) {\n        metaData.ticksPerBeat = weightedChoice(markovData.meta['ticksPerBeat']);\n    }\n    if (Object.getOwnPropertyNames(markovData.meta['SMPTEFrames']).length > 0) {\n        metaData.ticksPerBeat = weightedChoice(markovData.meta['SMPTEFrames']);\n    }\n    if (Object.getOwnPropertyNames(markovData.meta['ticksPerFrame']).length > 0) {\n        metaData.ticksPerBeat = weightedChoice(markovData.meta['ticksPerFrame']);\n    }\n\n    // now to build events for the key and time signatures, and the tempo.\n    // key signature\n    let codedKeySignature = '';\n    if (Object.getOwnPropertyNames(markovData.meta['keySignature']).length > 0) {\n        codedKeySignature = weightedChoice(markovData.meta['keySignature']);\n    }\n    // console.log(codedKeySignature);\n    let keySignature = {\n        delta: 0x00,\n        type: 0xff,\n        subtype: 0x59,\n        length: 0x02,\n        key: 0x00, // default 0x00\n        scale: 0x00 // default 0x00\n    }\n    let keyScaleArray = codedKeySignature.split('-')\n    // console.log(keyScaleArray);\n    keySignature.key = parseInt(keyScaleArray[0], 10);\n    keySignature.scale = parseInt(keyScaleArray[1], 10);\n    metaData.keySignature = keySignature;\n\n    // time signature\n    let codedTimeSignature = '';\n    if (Object.getOwnPropertyNames(markovData.meta['timeSignature']).length > 0) {\n        codedTimeSignature = weightedChoice(markovData.meta['timeSignature']);\n    }\n    // console.log(codedTimeSignature);\n    let timeSignature = {\n        delta: 0x00,\n        type: 0xff,\n        subtype: 0x58,\n        length: 0x04,\n        data: [0x00, 0x00, 0x00, 0x00],\n        param1: 0x00,\n        param2: 0x00,\n        param3: 0x00,\n        param4: 0x00\n    }\n    let timeDataStringArray = codedTimeSignature.split('-');\n    let timeDataArray = timeDataStringArray.map(element => {\n        return parseInt(element, 10);\n    });\n    timeSignature.data = timeDataArray;\n    timeSignature.param1 = timeDataArray[0];\n    timeSignature.param2 = timeDataArray[1];\n    timeSignature.param3 = timeDataArray[2];\n    timeSignature.param4 = timeDataArray[3];\n    metaData.timeSignature = timeSignature;\n\n    // tempo event\n    let codedTempo = '';\n    if (Object.getOwnPropertyNames(markovData.meta['tempo']).length > 0) {\n        codedTempo = weightedChoice(markovData.meta['tempo']);\n    }\n    // console.log(codedTempo);\n    let tempo = {\n        delta: 0x00,\n        type: 0xff,\n        subtype: 0x51,\n        length: 0x03,\n        tempo: 0x000000,\n    }\n    tempo.tempo = parseInt(codedTempo, 10);\n    metaData.tempo = tempo;\n\n    // console.log(metaData);\n    // that finishes the metadata\n\n\n    let tracks = {\n        1: undefined,\n        2: undefined,\n        3: undefined\n    }\n    // now we generate each track\n    // let firstTrack = generateTrack(markovData.map, order, 450)\n    // tracks[1] = firstTrack;\n    // console.log('1 track written');\n    // console.log(tracks);\n    for (let i = 1; i < 4; i++) {\n        tracks[i] = generateTrack(markovData.map, order, 450)\n    }\n\n    let generatedSong = {\n        trackNotes: tracks,\n        metaData: metaData\n    }\n\n    return generatedSong;\n}\n\nfunction generateTrack(noteMap, markovOrder, distance) {\n    let trackNotes = [];\n\n    let stateQueue = new Queue(markovOrder);\n\n    // get our first Markov state. find all the keys that start with\n    // a start token, then randomly select from them.\n    let markovKeys = Object.keys(noteMap);\n    let startingPossibilities = [];\n    markovKeys.forEach(markovKey => {\n        // console.log(markovKey);\n        let decodedKey = markovKey.split('|');\n        if (decodedKey[0] == START_TOKEN) {\n            startingPossibilities.push(markovKey);\n        }\n    });\n    // console.log(`Starting possibilities: ${startingPossibilities}`);\n    let state = startingPossibilities[Math.floor(Math.random() * startingPossibilities.length)];\n    state = state.split('|')\n    console.log(`First state:`);\n    console.log(state);\n    state.forEach(token => {\n        stateQueue.enqueue(token);\n    });\n\n    // now walk the path\n    for (let step = 0; step <= distance; step++) {\n        // save the queue state\n        state = stateQueue.items();\n        // step through the queue\n        let currentNote = stateQueue.dequeue();\n        // find another word to start the queue\n        if (currentNote == STOP_TOKEN) {\n            let allKeys = Object.keys(noteMap);\n            let newStartingPossibilities = [];\n            allKeys.forEach(allKey => {\n                let decodedKey = allKey.split('|')\n                if (decodedKey[0] == START_TOKEN) {\n                    newStartingPossibilities.push(allKey);\n                }\n            });\n            state = newStartingPossibilities[Math.floor(Math.random() * newStartingPossibilities.length)];\n            state = state.split('|')\n            state.forEach(token => {\n                stateQueue.enqueue(token);\n            });\n            currentNote = stateQueue.dequeue;\n        }\n        // start tokens aren't written\n        if (currentNote == START_TOKEN) {\n            let stateToken = state.join('|')\n            let setOfPossibilities = noteMap[stateToken];\n            let nextNote = weightedChoice(setOfPossibilities);\n            stateQueue.enqueue(nextNote);\n            state = stateQueue.items();\n            currentNote = stateQueue.dequeue();\n        }\n        // enqueue our next token\n        let stateToken = state.join('|')\n        let setOfPossibilities = noteMap[stateToken];\n        let nextNote = weightedChoice(setOfPossibilities);\n        stateQueue.enqueue(nextNote);\n\n        // turn the current note into an event\n        let decodedNote = nextNote.split('-');\n        let note = {\n            pitch: undefined,\n            velocity: undefined,\n            alpha: undefined,\n            duration: undefined\n        }\n        note.pitch = parseInt(decodedNote[0], 10)\n        note.velocity = parseInt(decodedNote[1], 10)\n        note.alpha = parseInt(decodedNote[2], 10)\n        note.duration = parseInt(decodedNote[3], 10)\n        trackNotes.push(note);\n\n        // debugging\n        if (trackNotes.length == 1) {\n            // console.log(trackNotes);\n        }\n    }\n    return trackNotes;\n}\n\n// need a random weighted choice function\nfunction weightedChoice(histogram) {\n    // let histogram = hashMap[property];\n    let choice = '';\n    let weightSum = Object.values(histogram).reduce((sum, element) => {\n        return sum + element;\n    })\n    // console.log(weightSum);\n    let randomWeight = Math.floor(Math.random() * weightSum)\n    // console.log(randomWeight);\n\n    let keys = Object.keys(histogram)\n    // console.log(keys);\n    let chosen = false\n    keys.forEach(key => {\n        if ((randomWeight - histogram[key] <= 0) && (chosen == false)) {\n            choice = key;\n            chosen = true;\n        } else if (chosen == false) {\n            randomWeight -= histogram[key];\n        }\n    });\n\n    return choice;\n}\n\nexport default generate;\n"],"file":"generate-midi.js"}