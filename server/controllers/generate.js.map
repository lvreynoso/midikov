{"version":3,"sources":["../../source/controllers/generate.js"],"names":["generate","express","Router","post","req","res","category","body","query","testMidiDBObjects","MIDIFile","find","catch","err","console","log","midiObjects","map","dbEntry","convertedMidi","data","deconstructedMidi","markovData","generatedSong","generatedMidi","generatedBinary","Buffer","from","getContent","generatedHex","toString","randomInt","Math","floor","random","generatedObject","title","hex","path","generatedJSON","JSON","stringify","status","send","get","testCategory","markovSources","midi","midiJSON","generatedMidiBinary","render","name","counter","forEach","filename"],"mappings":"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","sourcesContent":["// generate.js\n\n// app\nimport express from 'express'\nconst generate = express.Router()\n\n// disk i/o\nimport fs from 'fs'\n\n// models\nimport MIDIFile from '../models/MIDIFile.js'\n\n// midi manipulation\nimport midiFile from 'midifile'\nimport midiEvents from 'midievents'\nimport readMIDI from '../lib/read-midi.js'\nimport writeMIDI from '../lib/write-midi.js'\nimport transformMIDI from '../lib/transform-midi.js'\nimport generateMIDI from '../lib/generate-midi.js'\nimport assembleMIDI from '../lib/assemble.js'\nimport generateMap from '../lib/generate-map.js'\n\ngenerate.post('/', async (req, res) => {\n    // pull the midi from the database\n    const category = req.body.category;\n    const query = {\n        category: category\n    }\n\n    const testMidiDBObjects = await MIDIFile.find(query).catch(err => { console.log(err) });\n    const midiObjects = testMidiDBObjects.map(dbEntry => {\n        const convertedMidi = readMIDI(dbEntry.data);\n        const deconstructedMidi = transformMIDI(convertedMidi);\n        return deconstructedMidi;\n    });\n    // test with order 1\n    let markovData = generateMap(midiObjects, 1, category);\n    let generatedSong = generateMIDI(markovData, 1, category);\n    let generatedMidi = assembleMIDI(generatedSong);\n\n    // get all midis from a category\n    // const categoryMidis = await MIDIFile.find(query).catch(err => { console.log(err) });\n\n    // fake it until you make it...\n    // const randomMidi = categoryMidis[Math.floor(Math.random() * categoryMidis.length)]\n    // const sacrificedMidi = readMIDI(randomMidi.data);\n    // const transformMIDIdata = transformMIDI(sacrificedMidi);\n    // const frankenSong = assembleMIDI(transformMIDIdata);\n    // const frankenSongBinary = Buffer.from(frankenSong.getContent());\n    //\n    // const generatedHex = frankenSongBinary.toString('hex');\n\n    const generatedBinary = Buffer.from(generatedMidi.getContent());\n    const generatedHex = generatedBinary.toString('hex');\n\n    // write it to a file\n    // let path = 'public/temp/test.midi';\n    // let writeStream = fs.createWriteStream(path);\n    // writeStream.write(generatedHex, 'hex');\n    // writeStream.on('finish', () => {\n    //     console.log('Wrote data to file.');\n    // })\n    // writeStream.close();\n\n    let randomInt = Math.floor(Math.random() * 100);\n\n    // send the data\n    const generatedObject = {\n        title: `${category} - Generated id${randomInt}`,\n        hex: generatedHex,\n        path: '/temp/test.midi'\n    }\n    const generatedJSON = JSON.stringify(generatedObject);\n    res.status(200).send(generatedJSON);\n});\n\n// test Markov generation\ngenerate.get('/test', async (req, res) => {\n    // pull test midi from the data base\n    const testCategory = 'test';\n    const query = {\n        category: testCategory\n    };\n    const testMidiDBObjects = await MIDIFile.find(query).catch(err => { console.log(err) });\n    let markovSources = testMidiDBObjects.map(midi => {\n        let midiJSON = readMIDI(midi.data);\n        return midiJSON;\n    })\n\n    let generatedMidi = generateMIDI(markovSources);\n    let generatedMidiBinary = Buffer.from(generatedMidi.getContent());\n    writeMIDI(generatedMidiBinary, 'test_generate')\n\n    res.render('test');\n\n})\n\n// testing:\n// --> read midi from database\n// --> write midi to file\ngenerate.get('/write-test', async (req, res) => {\n    // pull test midi from the data base\n    const testCategory = 'test';\n    const query = {\n        category: testCategory\n    };\n    const testMidiDBObjects = await MIDIFile.find(query).catch(err => { console.log(err) });\n    let name = '_pianized_';\n    let counter = 1;\n    testMidiDBObjects.forEach(midi => {\n        let filename = `${counter}${name}${midi.title}`;\n        writeMIDI(midi.data, filename);\n        counter += 1;\n    })\n    // let testMidi = readMIDI(testMidiDBObjects[0].data);\n    // let transformedMIDI = transformMIDI(testMidi);\n    // writeMIDI(testMIDI);\n\n    res.render('test');\n\n})\n\nexport default generate;\n"],"file":"generate.js"}